# 4.2 肖恩的水杯Ⅲ

[肖恩的水杯Ⅲ【Q2建设】 - 蓝桥云课](https://www.lanqiao.cn/problems/3626/learning/)

### 问题描述

肖恩有一个水杯，水杯的最大容积为 $S$ 。小羊有 $n$ 个大小不同的装满水的杯子。肖恩可以在这 $n$ 个杯子中选择任意个连续的杯子，并把其中的水都倒进自己的杯子中。肖恩想知道自己有多少种选择方案，请你帮助他解决这个问题。

要注意的是，肖恩不想让杯子中的水溢出来，也就是说倒进去的水的体积不能大于 $S$ 。

### 输入描述

第一行输入两个整数 $n$ 和 $S$ ，分别表示小羊的杯子数量和肖恩的水杯容积。

第二行输入 $n$ 个整数，第 $i$ 个数字 $a[i]$ 表示小羊的第 $i$ 个杯子的体积。

数据保证： $1≤n≤10^5,1≤S≤2^{60},1≤a[i]≤10^9$ 。

### 输出描述

输出肖恩可以选择的方案数。

### 样例输入

```
5 3
2 5 4 1 2
```

### 样例输出

```
4
```

### 说明

肖恩可以选择的方案是：

1. 只选第 1 个杯子。
2. 只选第 4 个杯子。
3. 只选第 5 个杯子。
4. 同时选第 4 和第 5 个杯子。

### 运行限制

| 语言      | 最大运行时间 | 最大运行内存 |
| :------ | :----: | :----: |
| C++     |   1s   |  256M  |
| C       |   1s   |  256M  |
| Java    |   2s   |  256M  |
| Python3 |   3s   |  256M  |

### 解题思路

这道题也就是找到有多少个连续子序列，并且这些连续子序列的都和不大于 $S$ 。

连续子序列会有两个端点，所以我们当然可以用两层循环嵌套来枚举两个端点。外层循环枚举右端点的位置，内层循环枚举左端点的位置。然后我们还需要遍历子序列对其中的所有元素求和，所以总的时间复杂度是 $O(n^3)$ 。其中对于求和部分，我们可以用我们前面学过的前缀和来优化掉一层循环，这样可以达到 $O(n^2)$ 的时间复杂度。

但是这个时间复杂度显然不能够被接受的，所以我们来继续考虑优化。注意到题目中说明小羊的杯子体积都是正数，所以说如果选择更多的杯子总体积一定在变大，对应到我们的做法中就是在右端点固定的情况下左端点如果往左移动就一定会使和变大。假设右端点固定为 $r$ 的时候左端点为 $l$ 是满足序列和不大于 $S$ 的第一个位置$（\sum\limits_{i = l - 1}^r {a[i]}  > S）$，那么右端点变为 $r+1$ 的时候左端点一定大于等于 $l$ 。因为右端点向右移动的时候我们会在和中加上 $a[r+1]$ 的值，为了满足子序列和不大于 S 的条件，我们只能尝试右移左端点 $l$ 。

通过上面的分析我们发现左端点其实是有一定单调性的，他只能向右移动，所以我们就可以直接枚举右端点，向右移动左端点。这样我们就可以把 $O(n^2)$ 的循环嵌套优化到 $O(2×n)$ 的两次从左到右的枚举。

具体的解题步骤：

1. 定义两个指针，j 和 i ，分别表示子序列的左端点和右端点。初始时，将两个指针都指向第一个杯子。同时使用一个变量 sum 来记录当前滑动窗口中的杯子容量总和。
2. 我们开始移动子序列的端点位置。每次移动时，将右指针 i 向右移动一个位置，并将 sum 加上当前指向的杯子容量。如果 sum 的值大于 S，说明当前选择的杯子已经超出了最大容积 S ，必须向右移动左端点 j 的位置。
3. 在每次移动子序列端点位置的过程中，我们都可以记录当前子序列的长度，并更新最小长度 ans 的值。
4. 重复步骤 2−3 ，直到右指针 i 移动到最后一个杯子为止。
5. 最后，输出最大长度 ans ，即为肖恩所能选择的方案数量。

### 答案代码

* C++

```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int N = 1e5 + 10;
int q[N];
int n, m, sum, ans;

signed main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> q[i];
    }
    for (int i = 1, j = 1; i <= n; i++) {
        sum += q[i];
        while (sum > m) sum -= q[j], j++;
        ans += i - j + 1;
    }
    cout << ans;
}
```

* Java

```java
import java.util.Scanner;

public class Main {
    static final long N = 100010;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextLong();
        long m = scanner.nextLong();
        long[] q = new long[(int) N];

        for (int i = 1; i <= n; i++) {
            q[i] = scanner.nextLong();
        }

        long sum = 0;
        long ans = 0;
        long j = 1;

        for (int i = 1; i <= n; i++) {
            sum += q[i];
            while (sum > m) {
                sum -= q[(int) j];
                j++;
            }
            ans += i - j + 1;
        }

        System.out.println(ans);
    }
}
```

* Python

```python
N = 10 ** 5 + 10

n, m = map(int, input().split())
q = list(map(int, input().split()))
sum = 0
ans = 0

j = 1
for i in range(1, n + 1):
    sum += q[i - 1]
    while sum > m:
        sum -= q[j - 1]
        j += 1
    ans += i - j + 1

print(ans)
```