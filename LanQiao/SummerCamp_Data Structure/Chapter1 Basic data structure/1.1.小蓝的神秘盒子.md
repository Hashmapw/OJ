# 1.1 小蓝的神秘盒子

### 问题描述

在古老的城堡中，小蓝找到了一个神秘的盒子。这个盒子有一个奇特的魔法——每当有人对它说出一个数字，它就会制造一个能量值与数字相同的宝石，并存入盒子中，这些宝石会按照他们被制造出的顺序排列。但是，盒子也有个特殊的指令：

* 当人们对它说出 "0" 时，它就会把最新制造的宝石从盒子中取出。如果盒子中没有宝石，则不做任何操作。

小蓝想测试这个神秘盒子的魔法，他会按顺序对盒子说出 $n$ 个数字（包括 "0"），你的任务是模拟这个过程，并在说完这 $n$ 个数字后将盒子中的宝石的能量值逆序输出。

### 输入格式

输入的第一行包含一个整数 $n（1≤n≤10^5）$，表示小蓝会对盒子说出的数字的数量。

第二行包含 $n$ 个整数 $a_1​,a_2​,⋯,a_n​（1≤a_i​≤10^5）$，表示小蓝说出的数字。如果 $a_i​=0$，则从盒子中弹出最新的宝石。否则，盒子将制造并存入一个能量值为 $a_i$​ 的宝石。

### 输出格式

输出每一步后盒子中的宝石，每个宝石用其对应的数字表示。每一步的结果应该在新的一行中输出。

### 样例输入

```text
5
1 2 0 3 1
```

### 样例输出

```text
1
3
1
```

### 运行限制

| 语言      | 最大运行时间 | 最大运行内存 |
| :------ | :----: | :----: |
| C++     |   1s   |  256M  |
| C       |   1s   |  256M  |
| Java    |   2s   |  256M  |
| Python3 |   3s   |  256M  |

### 解题思路

这道题目的基本要求是模拟一个具有特殊操作规则的盒子。我们需要处理的每个操作可以分为两种类型：

* 如果小蓝说出的数字不为 0，则这个数字将作为一个新的宝石被放入盒子中。
* 如果小蓝说出的数字为 0，则盒子中最新的宝石将被取出。

在处理这种有先后顺序，并且需要进行插入和删除操作的问题时，栈是一种非常合适的数据结构。栈是一种具有“先进后出”性质的数据结构，新插入的元素总是被放在栈顶，而删除操作也总是删除栈顶的元素。这与题目描述的操作规则完全吻合。

因此，我们的思路就是使用一个栈来模拟这个盒子，小蓝说出的每个数字就是一个操作，我们按照这些操作的顺序来操作栈。

对于每个操作，我们需要进行以下处理：

* 如果小蓝说出的数字不为 0，那么我们就将这个数字插入到栈顶，表示将一个新的宝石放入盒子中。
* 如果小蓝说出的数字为 0，那么我们就删除栈顶的元素，表示从盒子中取出最新的宝石。需要注意的是，如果此时栈已经为空，我们应该忽略这个操作，因为题目描述中明确指出，如果盒子中没有宝石，则不做任何操作。

在所有操作结束后，我们需要将栈中的元素逆序输出。这是因为题目要求我们在说完所有数字后将盒子中的宝石的能量值逆序输出。由于栈的特性，栈顶的元素是最后放入盒子的宝石，而栈底的元素是最早放入盒子的宝石。因此，我们只需要依次取出栈顶的元素并输出，就可以得到逆序的宝石能量值。

具体的解题步骤如下：

1. 初始化一个空栈 `st`。

2. 读入小蓝会对盒子说出的数字的数量 n。

3. 进行 n 次操作。对于每次操作，读入小蓝说出的数字 x：

   * 如果 $x\ne 0$，则将 x 插入到栈顶；
   * 如果 $x=0$，则删除栈顶的元素。如果此时栈为空，则忽略这个操作。

4. 最后，当所有操作都结束后，依次取出栈顶的元素并输出，直到栈为空。这样我们就得到了盒子中的宝石的能量值的逆序。

如此，我们便可完成解题。

### 答案代码

* C++

```cpp
#include<bits/stdc++.h>
using namespace std;
int n , x;
signed main(){
  stack<int>st;
  cin >> n;
  for(int i = 1 ; i <= n ; i ++){
      cin >> x;
      if(!x) {
        if(st.empty()) continue ;
        else st.pop();
      } else st.push(x);
  }
  while(!st.empty()) {
    cout << st.top() << '\n';
    st.pop();
  }
  return 0;
}

copy
```

* Java

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            int x = scanner.nextInt();
            if (x == 0) {
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            } else {
                stack.push(x);
            }
        }
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }
        scanner.close();
    }
}

copy
```

* Python

```python
n = int(input())
stack = []
nums = list(map(int, input().split()))
for x in nums:
    if x == 0:
        if stack:
            stack.pop()
    else:
        stack.append(x)
while stack:
    print(stack.pop())
```