# 3.3 字符串的变换计数

### 问题描述

小蓝有一个长度为 n 的字符串 S，他准备进行字符串的变换。

设 $pre(i)$ 表示字符串 S 的前 $i$ 个字符构成的前缀：$s_1​s_2​s_3​...s_i$​。

$suf(i)$ 表示字符串 S 的后 $n−i+1$ 个字符构成的后缀：$s_i​s_{i+1}​s_{i+2}​...s_n$​。

他的变换操作如下：

选择一个 $i(1≤i<n)$，令字符串 $S=suf(i+1)+pre(i)$，即把字符串 $S$ 一个长度为 $i$ 的前缀移到末尾，和长度为 $n−i$ 的后缀拼接到一起，形成新的字符串。

例如：若 $S=abcd$ ，选择 $i=2$，则 $pre(i)=ab，suf(i+1)=cd$。

那么字符串 $S=suf(i+1)+pre(i)=cdab$ 。

小蓝现在会进行这样的操作 $10^{1000}$ 次，考虑所有可能的操作情况，他想让你帮他计算在他操作的过程中会形成多少种不同的字符串 $S$ 。

### 输入格式

输入共 2 行。

第 1 行输入一个正整数 $n$，表示字符串的长度。

第 2 行输入一个字符串，表示所给的字符串 $S$。

### 输出格式

在一行中输出一个整数，表示小蓝操作过程中能形成多少种不同的字符串 $S$。

### 样例输入

```
2
ab
```

### 样例输出

```
2
```

### 说明

一共能形成 $2$ 种不同的字符串：$ab$，$ba$。

因为一开始 $S$ 就是 $ab$，故 $ab$ 是可以形成的。

第一次操作选择 $i=1$，那么字符串 $S$ 将会变成 $ba$。

那么 $ba$ 也是可以形成的，在后续的操作中，显然已经无法形成其它不同的字符串了。

所以在操作过程中，他只能形成 $2$ 种不同的字符串。

### 评测数据规模

对于所有评测数据，$1≤n≤10^6$，且字符串 $S$ 只由小写字母构成。

### 运行限制

| 语言      | 最大运行时间 | 最大运行内存 |
| :------ | :----: | :----: |
| C++     |   2s   |  256M  |
| C       |   2s   |  256M  |
| Java    |   5s   |  512M  |
| Python3 |   10s  |  512M  |

### 解题思路
这里的做法是：枚举 $i$，每次利用字符串哈希将 $s_1​s_2​…s_i$​ 拼接到 $s_{i+1}​s_{i+2}​…s_n$​ 的末尾。

我们可以预处理两个数组：$h[i]，p[i]$，其中 $h[i]$ 表示 字符串前缀 $i$ 的哈希值，$p[i]$ 表示进制数的 $i$ 次方，那么我们根据这两个数组，预处理出前缀的哈希值，并利用前缀和的思想重新计算新字符串的哈希值。

每次枚举 $i$，我们可以得到将 $s_1​s_2​…s_i$​ 拼接到 $s_{i+1}​s_{i+2}​…s_{n}$​ 的末尾形成的新字符串的哈希值的式子： $Hash=(h[n]−h[i]∗p[n−i])∗p[i]+h[i]$ 然后将这些得到不同的 $Hash$ 值丢到一个 `unordered_set` 里面自动去重，这样我们就可以有效的统计不同的字符串数量了。

### 答案代码
* C++

```c++
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
const int N = 1e6 + 10;
ULL h[N], p[N], b = 131;


int main() {

    cin.tie(nullptr)->ios::sync_with_stdio(false);
    
    int n;
    cin >> n;
    string s;
    cin >> s;
    s = '?' + s;
    p[0] = 1;
    for (int i = 1; i <= n; i++) {
        p[i] = p[i - 1] * b;
        h[i] = h[i - 1] * b + s[i];
    }    
    unordered_set<ULL> se;
    for (int i = 1; i <= n; i++) {
        ULL hash = (h[n] - h[i] * p[n - i]) * p[i] + h[i];
        se.insert(hash);
    }
    cout << se.size() << '\n';

    return 0;
}
```